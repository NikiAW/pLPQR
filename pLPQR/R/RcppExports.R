# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Bisection Method for Probability Calculation
#'
#' This function implements an efficient bisection algorithm to compute probabilities
#' for quantile regression models. It performs a two-phase search:
#' a coarse search for rapid convergence followed by a fine search for precision.
#'
#' @param theta Numeric matrix of estimated parameters (p x K), where p is the number
#'   of covariates and K is the number of basis functions.
#' @param y Numeric vector of response values (length n).
#' @param X Numeric design matrix (n x p) containing covariates.
#' @param bf R function that computes the K-dimensional basis functions of tau.
#'   Should take a single numeric argument (tau) and return a numeric vector.
#' @param n_it Integer specifying the maximum number of iterations for the bisection
#'   algorithm. Default is 20.
#'
#' @return Numeric vector of probabilities (length n) in the range [0, 1] representing
#'   the estimated quantile levels for each observation.
#'
#' @details
#' The algorithm works as follows:
#' \itemize{
#'   \item \strong{Phase 1 (Coarse search, iterations 2-10)}: Uses large steps for
#'         rapid convergence to the approximate solution.
#'   \item \strong{Phase 2 (Fine search, iterations 11-n_it)}: Uses progressively
#'         smaller steps for high precision, with caching of basis function evaluations.
#' }
#'
#' The function employs caching to avoid repeated evaluations of the basis functions
#' at the same tau values, improving computational efficiency.
#'
#' @examples
#' \donttest{
#' # Example usage
#' set.seed(123)
#' n <- 100
#' p <- 3
#' K <- 2
#'
#' # Generate sample data
#' theta <- matrix(rnorm(p * K), nrow = p, ncol = K)
#' X <- matrix(rnorm(n * p), nrow = n, ncol = p)
#' y <- rnorm(n)
#'
#' # Define basis function
#' bf <- function(tau) {
#'   return(c(1, qnorm(tau)))
#' }
#'
#' # Compute probabilities
#' probabilities <- p_bisec_cpp(theta, y, X, bf, n_it = 20)
#' head(probabilities)
#' }
#'
#' @references
#' \itemize{
#'   \item Sottile, G., and Frumento, P. (2023). Parametric estimation of non-crossing quantile functions. Statistical Modelling, 23 (2), 173-195.
#' }
#'
#' @export
p_bisec_cpp <- function(theta, y, X, bf, n_it = 20L) {
    .Call(`_pLPQR_p_bisec_cpp`, theta, y, X, bf, n_it)
}

#' Simulate longitudinal data by a specified correlation matrix
#'
#' This function generates simulated longitudinal data using a copula-based approach
#' for composite quantile regression models. It creates correlated response data
#' with specified correlation structure across time points within subjects.
#'
#' @param thetahat Numeric matrix of estimated parameters (p x K), where p is the number
#'   of covariates and K is the number of basis functions.
#' @param X Numeric design matrix (n x p) containing covariates for all observations.
#' @param nsub Integer specifying the number of subjects in the longitudinal data.
#' @param bf R function that computes the K-dimensional basis functions of tau.
#'   Should take a single numeric argument (tau) and return a numeric vector.
#' @param index Integer vector indicating the time ordering within subjects.
#' @param id Integer vector identifying subject membership for each observation.
#' @param spcor Numeric matrix (m x m) specifying the spatial/temporal correlation
#'   structure between time points, where m is the number of time points per subject.
#'
#' @return A list containing the following components:
#' \describe{
#'   \item{y}{Numeric vector of simulated response values (length n).}
#'   \item{x}{Numeric design matrix, same as input X.}
#'   \item{tau_ij}{Numeric vector of quantile levels (length n) used for data generation.}
#'   \item{nsub}{Integer, number of subjects.}
#'   \item{index}{Integer vector, time ordering within subjects.}
#'   \item{id}{Integer vector, subject identifiers.}
#' }
#'
#' @details
#' The function implements the following data generation process:
#' \enumerate{
#'   \item \strong{Copula Generation}: Uses Cholesky decomposition of the correlation
#'         matrix to generate correlated normal samples, which are transformed to
#'         uniform [0,1] variables via the normal CDF.
#'   \item \strong{Quantile Levels}: The uniform variables serve as quantile levels
#'         (tau_ij) that introduce within-subject correlation.
#'   \item \strong{Response Generation}: For each observation, computes the basis
#'         functions at the generated quantile level, applies the parameter matrix
#'         to get time-varying coefficients, and generates the response as a linear
#'         combination of covariates and coefficients.
#' }
#'
#' This approach ensures that the simulated data maintains the specified correlation
#' structure across time points within each subject, making it suitable for
#' longitudinal data analysis.
#'
#' @examples
#' \donttest{
#' # Example: Simulate longitudinal data with 50 subjects and 3 time points
#' set.seed(123)
#' nsub <- 50
#' m <- 3  # time points per subject
#' n <- nsub * m
#' p <- 2  # number of covariates
#' K <- 2  # number of basis functions
#'
#' # Parameter matrix
#' thetahat <- matrix(c(1.0, 0.5, 0.3, 0.8), nrow = p, ncol = K)
#'
#' # Design matrix
#' X <- cbind(1, matrix(rnorm(n * (p-1)), nrow = n, ncol = p-1))
#'
#' # Basis function
#' bf <- function(tau) {
#'   return(c(1, qnorm(tau)))
#' }
#'
#' # Correlation structure (compound symmetry) using base R
#' rho <- 0.6
#' spcor <- (1 - rho) * diag(m) + rho * matrix(1, m, m)
#'
#' # Subject identifiers and time indices
#' id <- rep(1:nsub, each = m)
#' index <- rep(1:m, nsub)
#'
#' # Generate data
#' sim_data <- simdata_cpp(thetahat, X, nsub, bf, index, id, spcor)
#'
#' # Check the structure
#' str(sim_data)
#' head(sim_data$y)
#' }
#'
#' @export
simdata_cpp <- function(thetahat, X, nsub, bf, index, id, spcor) {
    .Call(`_pLPQR_simdata_cpp`, thetahat, X, nsub, bf, index, id, spcor)
}

#' Composite Quantile Regression with Parametric Coefficient Modeling
#'
#' Fits a composite quantile regression model for longitudinal data using parametric
#' modeling of quantile coefficients with different working correlation structures.
#'
#' @param x Numeric matrix of covariates (n x p), with rows sorted by subject and time.
#' @param y Numeric vector of responses (length n).
#' @param nk Integer vector, number of observations for each subject.
#' @param rowindex Integer vector indicating the starting row index (minus 1) for each subject.
#'   Should have length (nsub + 1) with rowindex[1] = 0 and rowindex[nsub+1] = n.
#' @param tau0 Numeric vector of quantile levels used for composite quantile regression.
#' @param nsub Integer, number of subjects.
#' @param nt Integer, number of tau levels.
#' @param gammaint Numeric vector of initial coefficient estimates (length p*K).
#' @param btau Numeric matrix of basis function values at tau0 (K x nt).
#' @param bderiv Numeric matrix of basis function derivative values at tau0 (K x nt).
#' @param K Integer, number of basis functions.
#' @param type Character, working correlation structure: "cs" (compound symmetry),
#'   "ar" (autoregressive), or "wi" (working independence).
#' @param wt Numeric vector of weights for different quantile levels (length nt).
#'
#' @return A list containing:
#' \item{gamma}{Estimated coefficient vector (length p*K)}
#' \item{cov}{Estimated covariance matrix of coefficients (p*K x p*K)}
#' \item{Dev}{Deviance value}
#' \item{AIC}{Akaike Information Criterion}
#' \item{BIC}{Bayesian Information Criterion}
#'
#' @details
#' This function implements composite quantile regression for longitudinal data
#' using parametric modeling of quantile coefficients. The method allows for
#' different working correlation structures to account for within-subject dependence:
#' \itemize{
#'  \item \code{"cs"}: Compound symmetry (exchangeable) correlation structure
#'   \item \code{"ar"}: Autoregressive structure of order 1
#'  \item \code{"wi"}: Working independence assumption
#' }
#'
#' The algorithm uses a quadratic inference function (QIF) approach and iteratively
#' updates coefficient estimates until convergence.
#'
#' @references Zhao, W., Lian, H., and Song, X. (2017). Composite quantile regression for correlated data.
#' Computational Statistics & Data Analysis, 109:15–33.
#' Fu, L., & Wang, Y. G. (2012). Quantile regression for longitudinal data
#' with a working correlation model. Computational Statistics & Data Analysis, 56(8), 2526-2538.
#' @export
cqr <- function(x, y, nk, rowindex, tau0, nsub, nt, gammaint, btau, bderiv, K, type, wt) {
    .Call(`_pLPQR_cqr`, x, y, nk, rowindex, tau0, nsub, nt, gammaint, btau, bderiv, K, type, wt)
}

#' Penalized Longitudinal Parametric Quantile Regression with Adaptive LASSO
#'
#' Fits a penalized longitudinal parametric quantile regression model with adaptive LASSO
#' penalty for a specific tuning parameter value. This function implements composite quantile
#' regression for longitudinal data using parametric modeling of quantile coefficients with
#' adaptive LASSO regularization to achieve variable selection.
#'
#' @param x Numeric matrix of covariates (n x p), with rows sorted by subject and time.
#' @param y Numeric vector of responses (length n).
#' @param nk Integer vector, number of observations for each subject.
#' @param rowindex Integer vector indicating the starting row index (minus 1) for each subject.
#'   Should have length (nsub + 1) with rowindex[1] = 0 and rowindex[nsub+1] = n.
#' @param tau0 Numeric vector of quantile levels used for composite quantile regression.
#' @param nsub Integer, number of subjects.
#' @param nt Integer, number of tau levels.
#' @param gammaint Numeric vector of initial coefficient estimates (length p*K).
#' @param v Numeric vector of adaptive weights for the LASSO penalty (length p*K).
#' @param rho Numeric, penalty parameter for the ADMM algorithm.
#' @param lambda Numeric, tuning parameter controlling the strength of LASSO regularization.
#' @param btau Numeric matrix of basis function values at tau0 (K x nt).
#' @param bderiv Numeric matrix of basis function derivative values at tau0 (K x nt).
#' @param K Integer, number of basis functions.
#' @param type Character, working correlation structure: "cs" (compound symmetry),
#'   "ar" (autoregressive), or "wi" (working independence).
#' @param wt Numeric vector of weights for different quantile levels (length nt).
#'
#' @return A list containing:
#' \item{gamma}{Estimated coefficient vector after adaptive LASSO regularization (length p*K)}
#' \item{cov}{Estimated covariance matrix of coefficients (p*K x p*K)}
#' \item{Q}{Quadratic inference function value}
#' \item{Dev}{Deviance value including penalty term}
#' \item{AIC}{Akaike Information Criterion with degrees of freedom adjustment}
#' \item{BIC}{Bayesian Information Criterion with degrees of freedom adjustment}
#'
#' @details
#' This function implements penalized composite quantile regression for longitudinal data
#' using the adaptive LASSO penalty. The method combines parametric modeling of quantile coefficients
#' and generalized unbiased estimating equations method with a adaptive LASSO penalty for variable selection.
#'
#' The algorithm uses the Alternating Direction Method of Multipliers (ADMM) to solve
#' the optimization problem with adaptive LASSO penalty. Three correlation structures
#' are supported:
#' \itemize{
#'   \item \code{"cs"}: Compound symmetry (exchangeable) correlation structure
#'   \item \code{"ar"}: Autoregressive structure of order 1
#'   \item \code{"wi"}: Working independence assumption
#' }
#'
#' The adaptive weights (\code{v}) are typically set to the inverse of initial coefficient
#' estimates to achieve the oracle properties of adaptive LASSO.
#'
#' @references Yu, Z., Yu, K.M., Ni, Y.X., & Tian, M.Z. (2025). Unravelling Determinants of Global Life Expectancy: A Joint Quantile Approach for Heterogeneous Longitudinal Studies.
#' @export
cqr_adlasso <- function(x, y, nk, rowindex, tau0, nsub, nt, gammaint, v, rho, lambda, btau, bderiv, K, type, wt) {
    .Call(`_pLPQR_cqr_adlasso`, x, y, nk, rowindex, tau0, nsub, nt, gammaint, v, rho, lambda, btau, bderiv, K, type, wt)
}

#' Basic Function of Cross-validation for Penalized Longitudinal Parametric Quantile Regression with Adaptive LASSO
#'
#' Performs cross-validation to select the optimal tuning parameter for penalized longitudinal
#' parametric quantile regression with adaptive LASSO penalty. This function evaluates
#' a sequence of lambda values and selects the one that minimizes the quadratic inference function
#' Bayesian Information Criterion (QIFBIC).
#'
#' @param type Character, working correlation structure: "cs" (compound symmetry),
#'   "ar" (autoregressive), or "wi" (working independence).
#' @param lambda Numeric vector of tuning parameters to evaluate.
#' @param x Numeric matrix of covariates (n x p), with rows sorted by subject and time.
#' @param y Numeric vector of responses (length n).
#' @param nk Integer vector, number of observations for each subject.
#' @param rowindex Integer vector indicating the starting row index (minus 1) for each subject.
#'   Should have length (nsub + 1) with rowindex[1] = 0 and rowindex[nsub+1] = n.
#' @param tau0 Numeric vector of quantile levels used for composite quantile regression.
#' @param nsub Integer, number of subjects.
#' @param nt Integer, number of tau levels.
#' @param gammaint Numeric vector of initial coefficient estimates (length p*K).
#' @param v Numeric vector of adaptive weights for the LASSO penalty (length p*K).
#' @param rho Numeric, penalty parameter for the ADMM algorithm.
#' @param btau Numeric matrix of basis function values at tau0 (K x nt).
#' @param bderiv Numeric matrix of basis function derivative values at tau0 (K x nt).
#' @param K Integer, number of basis functions.
#' @param wt Numeric vector of weights for different quantile levels (length nt).
#'
#' @return A list containing:
#' \item{r}{Optimal model results corresponding to the best lambda value}
#' \item{gamma}{Estimated coefficients from the optimal model}
#' \item{QIFBIC}{Optimal BIC value}
#' \item{lambda}{Optimal lambda value that minimizes BIC}
#' \item{rlist}{List of results for all lambda values evaluated}
#'
#' @details
#' This function performs cross-validation by evaluating a sequence of tuning parameters
#' (lambda values) for the adaptive LASSO penalty in penalized longitudinal parametric
#' quantile regression. The selection criterion is based on the Bayesian Information
#' Criterion (BIC), which balances model fit and complexity.
#'
#' Warm starting significantly improves computational efficiency by using the solution
#' from the previous lambda as the initial value for the next lambda.
#'
#' @seealso
#' \code{\link{cqr_adlasso}} for fitting the penalized model for a specific lambda value.
#' \code{\link{CV_cqr_adlasso}} for the R wrapper function that provides a more user-friendly interface.
#' @references Yu, Z., Yu, K.M., Ni, Y.X., & Tian, M.Z. (2025). Unravelling Determinants of Global Life Expectancy: A Joint Quantile Approach for Heterogeneous Longitudinal Studies.
#' @useDynLib pLPQR, .registration = TRUE
#' @importFrom Rcpp evalCpp
#' @export
cv_cqr_adlasso0 <- function(type, lambda, x, y, nk, rowindex, tau0, nsub, nt, gammaint, v, rho, btau, bderiv, K, wt) {
    .Call(`_pLPQR_cv_cqr_adlasso0`, type, lambda, x, y, nk, rowindex, tau0, nsub, nt, gammaint, v, rho, btau, bderiv, K, wt)
}

#' Goodness-of-Fit Tests for Penalized Longitudinal Parametric Quantile Regression
#'
#' Performs stratified analysis and goodness-of-fit testing for parametric quantile regression models.
#' This function computes probability integral transform (PIT) values and conducts
#' Cramér-von Mises and Kolmogorov-Smirnov tests to assess model adequacy across strata.
#'
#' @param data A list containing the dataset with the following components:
#'   \itemize{
#'     \item \code{y}: Numeric vector of responses
#'     \item \code{x}: Numeric matrix of covariates
#'     \item \code{id}: Numeric vector of subject identifiers
#'     \item \code{nsub}: Integer, number of subjects
#'     \item \code{index}: Numeric vector indicating stratum membership for each observation
#'   }
#' @param bf Function that computes basis functions, takes a quantile level tau and returns a numeric vector.
#' @param bderivf Function that computes derivatives of basis functions, takes a quantile level tau and returns a numeric vector.
#'
#' @return A list containing:
#' \item{cvm}{Global weighted Cramér-von Mises statistic across all strata}
#' \item{weights}{Numeric vector of weights for each stratum based on sample size}
#' \item{stats}{List containing stratum-specific test statistics:
#'   \itemize{
#'     \item \code{cvm}: Cramér-von Mises statistics for each stratum
#'     \item \code{ks}: Kolmogorov-Smirnov statistics for each stratum
#'   }}
#' \item{cvms}{Numeric vector of Cramér-von Mises statistics for each stratum}
#' \item{kss}{Numeric vector of Kolmogorov-Smirnov statistics for each stratum}
#' \item{PIT.S}{List of probability integral transform values for each stratum}
#'
#' @references Yu, Z., Yu, K.M., Ni, Y.X., & Tian, M.Z. (2025). Unravelling Determinants of Global Life Expectancy: A Joint Quantile Approach for Heterogeneous Longitudinal Studies.
#'
#' @seealso
#' \code{\link{cv_cqr_adlasso0}} for the cross-validation function used internally.
#' \code{\link{p_bisec_cpp}} for the probability integral transform computation.
#' @references Yu, Z., Yu, K.M., Ni, Y.X., & Tian, M.Z. (2025). Unravelling Determinants of Global Life Expectancy: A Joint Quantile Approach for Heterogeneous Longitudinal Studies.
#' Yang, C.-C., Chen, Y.-H., and Chang, H.-Y. (2017). Composite marginal quantile regression analysis for longitudinal adolescent body mass index data: Quantile regression for longitudinal adolescent BMI. Statistics in Medicine, 36(21):3380–3397.
#' @export
stratumCvM_para_test_cpp <- function(data, bf, bderivf) {
    .Call(`_pLPQR_stratumCvM_para_test_cpp`, data, bf, bderivf)
}

